"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[120],{4041:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api/types/index","title":"Types","description":"Zustand Storage leverages TypeScript interfaces and types to provide a robust, type-safe API for state management with persistence and optional database integration. This section outlines the key interfaces and types used within the package.","source":"@site/docs/api/types/index.md","sourceDirName":"api/types","slug":"/api/types/","permalink":"/zustand-storage/api/types/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"alphadevking","lastUpdatedAt":1740941703000,"frontMatter":{"title":"Types","sidebar_label":"Types"},"sidebar":"api","previous":{"title":"saveToDB","permalink":"/zustand-storage/api/saveToDB"}}');var r=n(612),i=n(7066);const a={title:"Types",sidebar_label:"Types"},o="Types",l={},c=[{value:"StorageEngine",id:"storageengine",level:2},{value:"MergeStrategy",id:"mergestrategy",level:2},{value:"SyncOptions",id:"syncoptions",level:2},{value:"StoreSet",id:"storeset",level:2},{value:"DatabaseIntegration",id:"databaseintegration",level:2},{value:"SyncedStoreConfig",id:"syncedstoreconfig",level:2},{value:"SyncedStore",id:"syncedstore",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"types",children:"Types"})}),"\n",(0,r.jsx)(t.p,{children:"Zustand Storage leverages TypeScript interfaces and types to provide a robust, type-safe API for state management with persistence and optional database integration. This section outlines the key interfaces and types used within the package."}),"\n",(0,r.jsx)(t.h2,{id:"storageengine",children:"StorageEngine"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"StorageEngine"})," interface abstracts the methods required for a storage backend. It defines functions to retrieve, store, and remove items."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export interface StorageEngine {\n  getItem(key: string): string | null;\n  setItem(key: string, value: string): void;\n  removeItem(key: string): void;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"getItem:"})," Retrieves the value associated with the provided key, or returns ",(0,r.jsx)(t.code,{children:"null"})," if not found."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"setItem:"})," Stores a value under the specified key."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"removeItem:"})," Deletes the key-value pair from storage."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"mergestrategy",children:"MergeStrategy"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"MergeStrategy"})," defines how the persisted state is merged with the initial state during rehydration."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export type MergeStrategy = 'deep' | 'shallow' | 'replace';\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"deep:"})," Recursively merges nested objects."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"shallow:"})," Merges only the top-level properties."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"replace:"})," Replaces the initial state entirely with the persisted state."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"syncoptions",children:"SyncOptions"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"SyncOptions"})," interface provides configuration options for state persistence, including debounce timing, serialization, and error handling."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export interface SyncOptions<State> {\n  debounce?: number;\n  serialize?: (state: State) => string;\n  deserialize?: (data: string) => State;\n  persistOn?: 'change' | 'interval';\n  interval?: number;\n  onError?: (error: Error) => void;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"debounce:"})," Delay (in milliseconds) to throttle persistence calls."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"serialize:"})," Function to convert state to a string before storage."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"deserialize:"})," Function to convert stored data back into state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"persistOn:"})," Determines when to persist state (",(0,r.jsx)(t.code,{children:"change"})," or ",(0,r.jsx)(t.code,{children:"interval"}),")."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"interval:"})," Time interval for periodic persistence when using interval mode."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"onError:"})," Callback invoked if an error occurs during persistence."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"storeset",children:"StoreSet"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"StoreSet"})," is a function type for updating the store's state. It accepts a partial state update or a function that computes the update."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export type StoreSet<State> = (\n  partial: Partial<State> | ((state: State) => Partial<State>),\n  replace?: boolean\n) => void;\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"partial:"})," Either a partial state object or a function that receives the current state and returns a partial update."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"replace:"})," Optional boolean flag to replace the entire state instead of merging."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"databaseintegration",children:"DatabaseIntegration"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"DatabaseIntegration"})," interface allows you to integrate an external database with your store. It specifies the client, table/collection name, and optional transformation functions."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export interface DatabaseIntegration<State> {\n  client: any; // Ideally, this should be of type DatabaseClient.\n  collectionOrTable: string;\n  fromRecord?: (record: any) => Partial<State>;\n  toRecord?: (state: State) => object;\n  onError?: (error: Error) => void;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"client:"})," The database client instance."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"collectionOrTable:"})," Name of the collection or table in the database."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"fromRecord:"})," (Optional) Function to transform a database record into a partial state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"toRecord:"})," (Optional) Function to transform the current state into a record for database storage."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"onError:"})," (Optional) Error handler for database operations."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"syncedstoreconfig",children:"SyncedStoreConfig"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"SyncedStoreConfig"})," defines the configuration for creating a synced store. It includes options for persistence, state merging, migration, and optional database integration."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export interface SyncedStoreConfig<State, Actions> {\n  key: string;\n  storageEngine?: StorageEngine;\n  initialState: State;\n  actions: (set: StoreSet<State>, get: () => State) => Actions;\n  syncOptions?: SyncOptions<State>;\n  mergeStrategy?: MergeStrategy;\n  migrate?: (persistedState: any) => State;\n  database?: DatabaseIntegration<State>;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"key:"})," Unique identifier for persisting state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"storageEngine:"})," (Optional) Custom storage engine; defaults to a built-in fallback."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"initialState:"})," The initial state of the store."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"actions:"})," Function that returns an object containing methods to update the state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"syncOptions:"})," (Optional) Options controlling persistence behavior."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"mergeStrategy:"})," (Optional) Strategy for merging persisted state with the initial state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"migrate:"})," (Optional) Function to migrate persisted state to the current structure."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"database:"})," (Optional) Configuration for integrating with an external database."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"syncedstore",children:"SyncedStore"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"SyncedStore"})," interface represents the store returned by ",(0,r.jsx)(t.code,{children:"createSyncedStore"}),". It provides hooks and methods for state management, persistence, and optional database synchronization."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export interface SyncedStore<State, Actions> {\n  useStore: () => [State, Actions];\n  getState: () => State;\n  setState: StoreSet<State>;\n  subscribe: (listener: (state: State) => void) => () => void;\n  persist: () => void;\n  rehydrate: () => void;\n  addMiddleware: (mw: (state: State) => State) => void;\n  resetStore: () => void;\n  actions: Actions;\n  fetchFromDB?: (query: object) => Promise<void>;\n  saveToDB?: (query: object) => Promise<void>;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"useStore:"})," React hook to access the current state and actions."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"getState:"})," Retrieves the current state synchronously."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"setState:"})," Function to update the state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"subscribe:"})," Registers a listener for state updates."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"persist:"})," Manually triggers state persistence."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"rehydrate:"})," Reloads state from storage."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"addMiddleware:"})," Adds middleware to process state updates."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"resetStore:"})," Resets the state to its initial value and clears persisted data."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"actions:"})," Object containing the predefined action methods."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"fetchFromDB:"})," (Optional) Fetches data from an external database."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"saveToDB:"})," (Optional) Saves the current state to an external database."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"These types provide a solid foundation for building state management solutions with persistence and database integration in Zustand Storage. They ensure type safety and clarity, helping you develop robust and maintainable applications."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},7066:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(4344);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);