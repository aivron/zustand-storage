"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[713],{7066:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(4344);const r={},i=n.createContext(r);function a(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(i.Provider,{value:t},e.children)}},9190:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"api/persist","title":"persist","description":"The persist function is used to manually trigger the persistence of the store\'s current state to the configured storage engine. This can be useful when you want to ensure that the latest state is saved immediately, outside of the automatic persistence triggers.","source":"@site/docs/api/persist.md","sourceDirName":"api","slug":"/api/persist","permalink":"/zustand-storage/api/persist","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"alphadevking","lastUpdatedAt":1740943107000,"frontMatter":{"title":"persist","sidebar_label":"persist"},"sidebar":"api","previous":{"title":"subscribe","permalink":"/zustand-storage/api/subscribe"},"next":{"title":"rehydrate","permalink":"/zustand-storage/api/rehydrate"}}');var r=s(612),i=s(7066);const a={title:"persist",sidebar_label:"persist"},o="persist",l={},c=[{value:"Usage",id:"usage",level:2},{value:"Additional Notes",id:"additional-notes",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"persist",children:"persist"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"persist"})," function is used to manually trigger the persistence of the store's current state to the configured storage engine. This can be useful when you want to ensure that the latest state is saved immediately, outside of the automatic persistence triggers."]}),"\n",(0,r.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import store from './store';\n\n// Manually persist the current state\nstore.persist();\n"})}),"\n",(0,r.jsx)(t.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Manual Trigger:"}),"\nWhile Zustand Storage automatically persists state changes based on your configuration (e.g., on change or at intervals), ",(0,r.jsx)(t.code,{children:"persist"})," gives you the flexibility to force a save at any moment."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Error Handling:"}),"\nIf an error occurs during persistence, the ",(0,r.jsx)(t.code,{children:"onError"})," callback provided in your syncOptions will be invoked."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Using ",(0,r.jsx)(t.code,{children:"persist"})," allows you to have more control over when your state is saved, ensuring that critical updates are not missed."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);